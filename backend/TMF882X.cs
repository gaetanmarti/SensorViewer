// Time-of-Flight distance sensors TMF882X
// Hookup guide: https://learn.sparkfun.com/tutorials/qwiic-dtof-imager-tmf882x-hookup-guide/all
// Datasheet: https://cdn.sparkfun.com/assets/learn_tutorials/2/2/8/9/TMF882X_DataSheet.pdf
// Firmware images: 
// 1. https://github.com/uwgraphics/mini_tof_firmware/blob/main/TMF882X/firmware/tmf882x_image.c
// 2. https://github.com/sparkfun/SparkFun_Qwiic_TMF882X_Arduino_Library/blob/main/src/tof_bin_image.c
// Host driver communication: https://look.ams-osram.com/m/5bfe4f6d8a09e607/original/TMF882X-Host-Driver-Communication-AN001015.pdf

namespace immensive;

// Interrupt status register (0xE1) bit field
public readonly struct IntStatus(byte value)
{
    public byte RawValue { get; } = value;

    // Bit 6: Status register has been set to non-zero value
    public bool Int7_StatusRegister => (RawValue & Int7()) != 0;

    // Bit 5: Received command has been handled
    public bool Int6_CommandHandled => (RawValue & Int6()) != 0;

    // Bit 3: Raw histogram is ready for readout
    public bool Int4_HistogramReady => (RawValue & Int4()) != 0;

    // Bit 1: Measurement result is ready for readout
    public bool Int2_MeasurementReady => (RawValue & Int2()) != 0;

    // Clear specific interrupt bit by writing 1 to it
    public static byte Int7() => 0x40;
    public static byte Int6() => 0x20;
    public static byte Int4() => 0x08;
    public static byte Int2() => 0x02;
}

public class TMF882X: II2CDevice
{
    // TMF882X Register addresses
    private const byte REG_APPID = 0x00;
    private const byte REG_CMD_STAT = 0x08;
    private const byte REG_INT_STATUS = 0xE1;
    private const byte REG_ENABLE = 0xE0;
    private const byte REG_CONFIG_RESULT = 0x20;

    // When page "common config" (cid_rid=0x16) is loaded :
    private const byte REG_PERIOD_LSB = 0x24;
    private const byte REG_PERIOD_MSB = 0x25;
    private const byte REG_KILO_ITER_LSB = 0x26;
    private const byte REG_KILO_ITER_MSB = 0x27;

    // When the "results" page (cid_rid=0x10) is active :
    private const byte REG_CONF0 = 0x38;
    private const byte REG_DIST0_LSB = 0x39;
    private const byte REG_DIST0_MSB = 0x3A;
    
    // Commands
    
    // Measure: start a cyclic measurement according to the configuration
    private const byte CMD_MEASURE = 0x10;
    // Configuration page (whatever page has been loaded to registers 0x20 andfollowing will be written to the device)
    private const byte CMD_WRITE_CONFIG_PAGE = 0x15;
    // Load Configuration Page 0 - common configuration
    private const byte CMD_LOAD_CONFIG_PAGE_COMMON = 0x16;
    // Stop: Abort any ongoing measurement
    private const byte CMD_STOP = 0xFF;

    // Bootloader commands (chapter 3)
    private const byte CMD_DOWNLOAD_INIT = 0x14;
    private const byte CMD_W_RAM = 0x41;
    private const byte CMD_SET_ADDR = 0x43;
    private const byte CMD_RAMREMAP_RESET = 0x11;
    private const byte  CMD_STAT = 0x08;
    
    public TMF882X(int address = 0x41) : base(address)
    {
        Name = "TMF882X Time-of-Flight Sensor";
    }

    public override bool TryDetect(int busId)
    {
        try
        {
            I2C = new I2C(busId, Address);
            if (!I2C.Ping())
            {
                Reset();
                return false;
            }
            // Will generate an exception if device doesn't respond or doesn't have expected registers
            /*void*/ GetAppId();
            return true;
        }
        catch
        {
            Reset();
            return false;
        }
    }

    public enum AppId : byte
    {
        Bootloader = 0x80, // Bootloader running
        Application = 0x03 // Measurement application running
    }

    public override void Initialize(Dictionary<string, string> config, int busId = -1)
    {
        base.Initialize(config, busId);

        var appId = GetAppId();
        switch (appId)
        {
            case AppId.Application:
                // Already running application, nothing to do
                break;
            case AppId.Bootloader:
                // Download and start RAM bootloader
                DownloadImage();
                //WaitForAppId(AppId.RamBootloader);
                break;
            default:
                throw new Exception($"TMF882X: unexpected APPID=0x{appId:X2}.");
        }
        

        // Additional initialization if needed
    }

    public AppId GetAppId()
    {
        byte appId = I2C.ReadReg(REG_APPID);
        return appId switch
        {
            0x03 => AppId.Application,
            0x80 => AppId.Bootloader,
            _ => throw new Exception($"TMF882X: APPID=0x{appId:X2} (unexpected value).")
        };
    }

    public enum EnableFlags : byte
    {
        CpuReady = (1 << 6),
        Pon = (1 << 0)
    }

    public bool IsEnabled ()
    {
        byte en = I2C.ReadReg(REG_ENABLE);
        return (en & ((byte)EnableFlags.CpuReady | (byte)EnableFlags.Pon)) != 0;
    }

    private byte[] _image  = [
        0x00, 0x80, 0x20, 0x00, 0x9D, 0x00, 0x20, 0x00, 0xD5, 0x20, 0x10, 0x00,
        0xD7, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x09, 0x12, 0x56, 0x34, 0xAC, 0x09, 0x00, 0x00, 0xD9, 0x20, 0x10, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDB, 0x20, 0x10, 0x00,
        0xDD, 0x20, 0x10, 0x00, 0xDF, 0x20, 0x10, 0x00, 0xAD, 0x22, 0x10, 0x00,
        0x61, 0x23, 0x10, 0x00, 0xDF, 0x20, 0x10, 0x00, 0x85, 0x22, 0x10, 0x00,
        0x99, 0x22, 0x10, 0x00, 0xDF, 0x20, 0x10, 0x00, 0xDF, 0x20, 0x10, 0x00,
        0xDF, 0x20, 0x10, 0x00, 0x51, 0x23, 0x10, 0x00, 0xE1, 0x20, 0x10, 0x00,
        0xE1, 0x20, 0x10, 0x00, 0x05, 0x24, 0x10, 0x00, 0x2D, 0x24, 0x10, 0x00,
        0x4D, 0x24, 0x10, 0x00, 0xDF, 0x20, 0x10, 0x00, 0xDF, 0x20, 0x10, 0x00,
        0x53, 0x29, 0xCD, 0x68, 0x03, 0x48, 0x85, 0x46, 0x00, 0xF0, 0x16, 0xF8,
        0x00, 0x48, 0x00, 0x47, 0xE1, 0x00, 0x20, 0x00, 0x00, 0x80, 0x20, 0x00,
        0x05, 0x48, 0x80, 0x47, 0x05, 0x48, 0x00, 0x47, 0xFE, 0xE7, 0xFE, 0xE7,
        0xFE, 0xE7, 0xFE, 0xE7, 0x70, 0x47, 0xFE, 0xE7, 0x70, 0x47, 0x00, 0x00,
        0xED, 0x6D, 0x10, 0x00, 0x89, 0x00, 0x20, 0x00, 0x06, 0x4C, 0x01, 0x25,
        0x06, 0x4E, 0x05, 0xE0, 0xE3, 0x68, 0x07, 0xCC, 0x2B, 0x43, 0x0C, 0x3C,
        0x98, 0x47, 0x10, 0x34, 0xB4, 0x42, 0xF7, 0xD3, 0xFF, 0xF7, 0xDC, 0xFF,
        0xAC, 0x09, 0x20, 0x00, 0xAC, 0x09, 0x20, 0x00, 0x10, 0xB5, 0x00, 0xF0,
        0x01, 0xF9, 0x00, 0xF0, 0x2D, 0xF9, 0x10, 0xBD, 0xF3, 0xB5, 0x8D, 0xB0,
        0x04, 0xF7, 0x82, 0xFA, 0x30, 0x30, 0x0C, 0x90, 0x58, 0x48, 0x18, 0x21,
        0x41, 0x56, 0x58, 0x20, 0x41, 0x43, 0x0C, 0x98, 0x08, 0x30, 0x0C, 0x18,
        0x00, 0xBF, 0x00, 0x26, 0x00, 0x21, 0x53, 0x48, 0x60, 0x38, 0x01, 0x77,
        0x0D, 0x98, 0x08, 0x90, 0x50, 0x48, 0x00, 0x69, 0x06, 0x90, 0xC8, 0x21,
        0x4E, 0x48, 0x01, 0x61, 0x00, 0x20, 0x07, 0xAB, 0x01, 0x90, 0x02, 0x90,
        0x00, 0x93, 0x03, 0x90, 0x4B, 0x48, 0x01, 0x23, 0x09, 0xAA, 0x80, 0x21,
        0x45, 0x6B, 0x08, 0x98, 0xA8, 0x47, 0x05, 0x90, 0x46, 0x49, 0x06, 0x98,
        0x08, 0x61, 0x05, 0x98, 0x01, 0x28, 0x07, 0xDA, 0x01, 0x20, 0xC0, 0x03,
        0xA0, 0x60, 0x44, 0x48, 0x20, 0x63, 0x76, 0x1C, 0x00, 0xBF, 0x03, 0xE0,
        0x09, 0x98, 0xA0, 0x60, 0x0A, 0x98, 0x20, 0x63, 0xA0, 0x68, 0x04, 0x90,
        0x01, 0x25, 0x54, 0xE0, 0x69, 0x02, 0x0D, 0x98, 0x08, 0x18, 0x08, 0x90,
        0x00, 0x20, 0x07, 0xAA, 0x02, 0x90, 0x01, 0x95, 0x00, 0x92, 0x03, 0x90,
        0x37, 0x48, 0x01, 0x23, 0x09, 0xAA, 0x80, 0x21, 0x47, 0x6B, 0x08, 0x98,
        0xB8, 0x47, 0x05, 0x90, 0x05, 0x98, 0x01, 0x28, 0x0C, 0xDA, 0x76, 0x1C,
        0xAA, 0x00, 0x21, 0x46, 0x08, 0x31, 0x04, 0x98, 0x88, 0x50, 0x01, 0x21,
        0xAA, 0x00, 0x20, 0x46, 0x30, 0x30, 0x81, 0x50, 0x00, 0xBF, 0x31, 0xE0,
        0x05, 0x22, 0xD2, 0x03, 0x04, 0x98, 0x80, 0x1A, 0x09, 0x99, 0x81, 0x42,
        0x04, 0xD3, 0x04, 0x98, 0x80, 0x18, 0x09, 0x99, 0x81, 0x42, 0x15, 0xD9,
        0xAA, 0x00, 0x20, 0x46, 0x08, 0x30, 0xA1, 0x68, 0x81, 0x50, 0xAA, 0x00,
        0x28, 0x30, 0x21, 0x6B, 0x81, 0x50, 0x02, 0x21, 0xAA, 0x00, 0x81, 0x50,
        0xA9, 0x00, 0x40, 0x58, 0x20, 0x49, 0x88, 0x42, 0x01, 0xD9, 0x00, 0xBF,
        0x00, 0xBF, 0x76, 0x1C, 0x00, 0xBF, 0x0F, 0xE0, 0xAA, 0x00, 0x20, 0x46,
        0x08, 0x30, 0x09, 0x99, 0x81, 0x50, 0xAA, 0x00, 0x28, 0x30, 0x0A, 0x99,
        0x81, 0x50, 0xA9, 0x00, 0x40, 0x58, 0x17, 0x49, 0x88, 0x42, 0x01, 0xD9,
        0x00, 0xBF, 0x00, 0xBF, 0x6D, 0x1C, 0x0A, 0x2D, 0xA8, 0xDB, 0x00, 0x20,
        0x0E, 0xE0, 0x82, 0x00, 0x21, 0x46, 0x30, 0x31, 0x8B, 0x58, 0x0D, 0x4A,
        0x18, 0x21, 0x51, 0x56, 0x28, 0x22, 0x51, 0x43, 0x0A, 0x4A, 0x40, 0x3A,
        0x89, 0x18, 0x82, 0x00, 0x8B, 0x50, 0x40, 0x1C, 0x0A, 0x28, 0xEE, 0xDB,
        0x01, 0x21, 0x06, 0x48, 0x60, 0x38, 0x01, 0x77, 0x00, 0x2E, 0x01, 0xD1,
        0x00, 0xBF, 0x01, 0xE0, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0x20, 0x0F, 0xB0,
        0xF0, 0xBD, 0x00, 0x00, 0x80, 0x3B, 0x20, 0x00, 0x38, 0x3C, 0x20, 0x00,
        0xD2, 0x04, 0x00, 0x00, 0x60, 0xEA, 0x00, 0x00, 0x30, 0xB5, 0x04, 0x46,
        0x0B, 0x48, 0x84, 0x42, 0x01, 0xDD, 0xFF, 0x20, 0x30, 0xBD, 0x29, 0x2C,
        0x01, 0xDA, 0x20, 0x46, 0xFA, 0xE7, 0x20, 0x46, 0x00, 0xF0, 0x12, 0xF8,
        0x06, 0x49, 0x40, 0x1A, 0x06, 0x49, 0x48, 0x43, 0x00, 0x12, 0x05, 0x21,
        0xC9, 0x02, 0x45, 0x18, 0x28, 0x46, 0x80, 0x30, 0x00, 0x12, 0xEB, 0xE7,
        0x24, 0x84, 0x2E, 0x00, 0x52, 0x05, 0x00, 0x00, 0x42, 0x0D, 0x00, 0x00,
        0x10, 0xB5, 0x03, 0x46, 0x19, 0x02, 0x00, 0x20, 0x80, 0x22, 0x03, 0xE0,
        0x4C, 0x1C, 0x61, 0x10, 0xFF, 0x30, 0x01, 0x30, 0x01, 0x24, 0x64, 0x02,
        0xA1, 0x42, 0xF7, 0xDC, 0x00, 0xBF, 0x0C, 0x46, 0x4C, 0x43, 0x21, 0x12,
        0x01, 0x24, 0x64, 0x02, 0xA1, 0x42, 0x02, 0xDB, 0x4C, 0x1C, 0x61, 0x10,
        0x80, 0x18, 0x52, 0x10, 0x00, 0x2A, 0xF2, 0xD1, 0x10, 0xBD, 0x00, 0x00,
        0x10, 0xB5, 0x02, 0xF7, 0x6B, 0xFC, 0x0E, 0x48, 0x0E, 0x49, 0xC8, 0x60,
        0x0E, 0x48, 0x0F, 0x49, 0x88, 0x63, 0x0F, 0x48, 0xC8, 0x64, 0x00, 0x20,
        0x06, 0xE0, 0x41, 0x00, 0x0D, 0x4A, 0x52, 0x5A, 0x43, 0x00, 0x0D, 0x49,
        0xCA, 0x52, 0x40, 0x1C, 0x21, 0x28, 0xF6, 0xDB, 0x02, 0x21, 0x03, 0x20,
        0x04, 0xF7, 0xF0, 0xFD, 0x03, 0x21, 0x08, 0x46, 0x04, 0xF7, 0xEC, 0xFD,
        0x10, 0xBD, 0x00, 0x00, 0x1D, 0x09, 0x20, 0x00, 0x38, 0x3F, 0x20, 0x00,
        0x4D, 0x03, 0x20, 0x00, 0x38, 0x3C, 0x20, 0x00, 0xED, 0x00, 0x20, 0x00,
        0x68, 0x09, 0x20, 0x00, 0xF6, 0x3A, 0x20, 0x00, 0x10, 0xB5, 0x02, 0xF7,
        0x55, 0xFD, 0x10, 0xBD, 0xF7, 0xB5, 0xA4, 0xB0, 0x14, 0x46, 0x04, 0xF7,
        0x51, 0xF9, 0x18, 0x90, 0x00, 0x2C, 0x05, 0xD1, 0xF7, 0x48, 0x00, 0x8A,
        0x40, 0x1C, 0x81, 0xB2, 0xF5, 0x48, 0x01, 0x82, 0x04, 0xF7, 0x46, 0xF9,
        0x06, 0x46, 0x30, 0x36, 0x24, 0x22, 0x00, 0x21, 0x1A, 0xA8, 0x07, 0xF7,
        0xC3, 0xFC, 0x24, 0x98, 0x19, 0x90, 0xF0, 0x48, 0x40, 0x68, 0x16, 0x90,
        0xED, 0x48, 0x80, 0x38, 0x00, 0x69, 0x15, 0x90, 0xC8, 0x21, 0xEB, 0x48,
        0x80, 0x38, 0x01, 0x61, 0x00, 0x20, 0x17, 0xAB, 0x01, 0x90, 0x02, 0x90,
        0x00, 0x93, 0x03, 0x90, 0xE8, 0x48, 0x01, 0x23, 0x1A, 0xAA, 0x80, 0x21,
        0x45, 0x6B, 0x19, 0x98, 0xA8, 0x47, 0x14, 0x90, 0xE2, 0x49, 0x80, 0x39,
        0x15, 0x98, 0x08, 0x61, 0xE1, 0x49, 0x16, 0x98, 0x48, 0x60, 0x14, 0x98,
        0x00, 0x28, 0x02, 0xD1, 0x24, 0x20, 0x27, 0xB0, 0xF0, 0xBD, 0xDF, 0x48,
        0x13, 0x90, 0xDD, 0x48, 0x22, 0x46, 0x80, 0x21, 0x83, 0x6E, 0x13, 0x98,
        0x98, 0x47, 0x00, 0x2C, 0x07, 0xD1, 0x00, 0x20, 0xD7, 0x49, 0x48, 0x60,
        0x88, 0x60, 0xD9, 0x49, 0xD4, 0x48, 0x80, 0x38, 0xC1, 0x61, 0x1A, 0x98,
        0xC0, 0x13, 0x12, 0x90, 0x12, 0x98, 0x40, 0x1E, 0x81, 0x00, 0x19, 0x98,
        0x41, 0x58, 0x12, 0x98, 0x82, 0x00, 0x19, 0x98, 0x80, 0x58, 0x09, 0x18,
        0x12, 0x98, 0x40, 0x1C, 0x82, 0x00, 0x19, 0x98, 0x80, 0x58, 0x08, 0x18,
        0xCA, 0x49, 0xC8, 0x60, 0xC8, 0x48, 0xE0, 0x38, 0x00, 0x7F, 0x00, 0x28,
        0x32, 0xD1, 0x58, 0x20, 0x60, 0x43, 0x31, 0x46, 0x08, 0x31, 0x40, 0x18,
        0x1A, 0x9A, 0x82, 0x60, 0xC7, 0x4A, 0x58, 0x20, 0x60, 0x43, 0x40, 0x18,
        0x02, 0x63, 0x01, 0x21, 0xC9, 0x03, 0xC5, 0x48, 0x81, 0x63, 0x01, 0x20,
        0x1C, 0xE0, 0x58, 0x21, 0x61, 0x43, 0x32, 0x46, 0x08, 0x32, 0x89, 0x18,
        0x8B, 0x68, 0x58, 0x21, 0x61, 0x43, 0x89, 0x18, 0x08, 0x31, 0x82, 0x00,
        0x8B, 0x50, 0x03, 0x23, 0x58, 0x21, 0x61, 0x43, 0x32, 0x46, 0x08, 0x32,
        0x89, 0x18, 0x30, 0x31, 0x82, 0x00, 0x8B, 0x50, 0x28, 0x21, 0x61, 0x43,
        0xB7, 0x4A, 0x40, 0x32, 0x89, 0x18, 0x82, 0x00, 0x8B, 0x50, 0x40, 0x1C,
        0x0A, 0x28, 0xE0, 0xDB, 0x00, 0xBF, 0x1E, 0xE0, 0x04, 0xF7, 0xB6, 0xF8,
        0x05, 0x46, 0x30, 0x35, 0xB0, 0x48, 0x80, 0x38, 0x40, 0x68, 0x00, 0x28,
        0x03, 0xD0, 0xBA, 0x20, 0x40, 0x5B, 0x00, 0x28, 0x04, 0xD1, 0x01, 0x21,
        0xC9, 0x03, 0xAB, 0x48, 0x81, 0x63, 0x09, 0xE0, 0xBA, 0x22, 0x51, 0x5B,
        0xA8, 0x4A, 0x80, 0x3A, 0x52, 0x68, 0xD0, 0x03, 0xFF, 0xF6, 0x3C, 0xFE,
        0xA5, 0x49, 0x88, 0x63, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0x20,
        0x22, 0xE0, 0x01, 0x21, 0x1D, 0xE0, 0x58, 0x23, 0x43, 0x43, 0x35, 0x46,
        0x08, 0x35, 0x5B, 0x19, 0x30, 0x33, 0x8D, 0x00, 0x5B, 0x59, 0x9D, 0x4D,
        0x80, 0x3D, 0xED, 0x69, 0x6B, 0x43, 0x9A, 0x0A, 0x28, 0x23, 0x43, 0x43,
        0x99, 0x4D, 0x40, 0x35, 0x5B, 0x19, 0x8D, 0x00, 0x5B, 0x59, 0x93, 0x42,
        0x06, 0xD2, 0x28, 0x23, 0x43, 0x43, 0x95, 0x4D, 0x40, 0x35, 0x5B, 0x19,
        0x8D, 0x00, 0x5A, 0x51, 0x49, 0x1C, 0x0A, 0x29, 0xDF, 0xDB, 0x40, 0x1C,
        0x02, 0x28, 0xDA, 0xDB, 0x01, 0x25, 0xD0, 0xE1, 0x8A, 0x48, 0xC0, 0x6A,
        0x00, 0x28, 0x02, 0xD0, 0x88, 0x49, 0xC8, 0x6A, 0x80, 0x47, 0x24, 0x22,
        0x00, 0x21, 0x1A, 0xA8, 0x07, 0xF7, 0xE8, 0xFB, 0x69, 0x02, 0x24, 0x98,
        0x08, 0x18, 0x19, 0x90, 0x58, 0x20, 0x60, 0x43, 0x37, 0x46, 0x08, 0x37,
        0xC0, 0x19, 0x08, 0x30, 0xAF, 0x00, 0xC2, 0x59, 0xA7, 0x00, 0x82, 0x48,
        0x58, 0x38, 0xC0, 0x59, 0x80, 0x30, 0x01, 0x6B, 0x7B, 0x48, 0x03, 0x6F,
        0x19, 0x98, 0x98, 0x47, 0x11, 0x90, 0x00, 0x21, 0x17, 0xAA, 0x11, 0x98,
        0x01, 0x95, 0x00, 0x92, 0x02, 0x91, 0x03, 0x90, 0x75, 0x48, 0x03, 0x23,
        0x1A, 0xAA, 0x80, 0x21, 0x47, 0x6B, 0x19, 0x98, 0xB8, 0x47, 0x14, 0x90,
        0x14, 0x98, 0x00, 0x28, 0x02, 0xD1, 0x00, 0xBF, 0x00, 0xBF, 0x97, 0xE1,
        0x58, 0x20, 0x60, 0x43, 0x31, 0x46, 0x08, 0x31, 0x40, 0x18, 0x08, 0x30,
        0xA9, 0x00, 0x42, 0x58, 0x68, 0x48, 0x80, 0x69, 0x6D, 0x49, 0x89, 0x6B,
        0x01, 0x23, 0xDB, 0x03, 0xC9, 0x1A, 0x48, 0x43, 0x00, 0x13, 0x10, 0x1A,
        0x10, 0x90, 0x00, 0x20, 0x0F, 0x90, 0x0E, 0x90, 0x0D, 0x90, 0x01, 0x20,
        0x0C, 0x90, 0x0C, 0xA8, 0x23, 0x46, 0x2A, 0x46, 0x00, 0x90, 0x1A, 0xA8,
        0x10, 0x99, 0x02, 0xF7, 0xCB, 0xF8, 0x00, 0x28, 0x01, 0xD0, 0x01, 0x20,
        0x00, 0xE0, 0x00, 0x20, 0x0B, 0x90, 0xA2, 0x00, 0x58, 0x48, 0x5C, 0x38,
        0x80, 0x58, 0x1B, 0x99, 0x81, 0x42, 0x01, 0xD9, 0x01, 0x20, 0x00, 0xE0,
        0x00, 0x20, 0x0A, 0x90, 0x00, 0x20, 0x09, 0x90, 0x0B, 0x98, 0x00, 0x28,
        0x05, 0xD0, 0x0A, 0x98, 0x00, 0x28, 0x02, 0xD0, 0x01, 0x20, 0x09, 0x90,
        0x07, 0xE0, 0x0B, 0x98, 0x00, 0x28, 0x04, 0xD0, 0x01, 0x20, 0x0E, 0x90,
        0x0D, 0x98, 0x40, 0x1C, 0x0D, 0x90, 0x0E, 0x98, 0x00, 0x28, 0x01, 0xD0,
        0x00, 0xBF, 0x01, 0xE0, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0x20, 0x08, 0x90,
        0x01, 0x20, 0x07, 0x90, 0x0E, 0x98, 0x00, 0x28, 0x02, 0xD0, 0x1A, 0x98,
        0x08, 0x90, 0x01, 0xE0, 0x10, 0x98, 0x08, 0x90, 0x07, 0x98, 0x00, 0x28,
        0x18, 0xD0, 0x3F, 0x48, 0x01, 0x8A, 0x40, 0x8A, 0x81, 0x42, 0x02, 0xDD,
        0x3C, 0x48, 0x41, 0x8A, 0x01, 0x82, 0x28, 0x20, 0x60, 0x43, 0x3A, 0x49,
        0x40, 0x39, 0x40, 0x18, 0xA9, 0x00, 0x47, 0x18, 0x37, 0x49, 0x0A, 0x8A,
        0x38, 0x68, 0x08, 0x99, 0x03, 0xF7, 0xB1, 0xF8, 0x38, 0x60, 0x38, 0x68,
        0x08, 0x90, 0x00, 0xBF, 0x0C, 0x98, 0x01, 0x28, 0x04, 0xD1, 0x18, 0x98,
        0x01, 0x6A, 0x10, 0x98, 0x40, 0x1A, 0x08, 0x90, 0x00, 0x20, 0x06, 0x90,
        0x0D, 0x9F, 0x12, 0xE1, 0x0B, 0x98, 0x00, 0x28, 0x3D, 0xD0, 0x09, 0x98,
        0x00, 0x28, 0x3A, 0xD1, 0x07, 0x22, 0xD2, 0x03, 0x08, 0x98, 0x80, 0x18,
        0x1D, 0x99, 0x81, 0x42, 0x33, 0xDD, 0x17, 0x98, 0x40, 0x1C, 0x4B, 0x22,
        0x50, 0x43, 0x1E, 0x99, 0x81, 0x42, 0x2C, 0xDD, 0x1B, 0x98, 0x58, 0x21,
        0x61, 0x43, 0x32, 0x46, 0x08, 0x32, 0x89, 0x18, 0x30, 0x31, 0xAA, 0x00,
        0x89, 0x58, 0x24, 0x4A, 0x80, 0x3A, 0xD2, 0x69, 0x51, 0x43, 0x89, 0x0A,
        0x03, 0x91, 0xA2, 0x00, 0x1A, 0x49, 0x5C, 0x39, 0x89, 0x58, 0x81, 0x42,
        0x03, 0xD2, 0xA2, 0x00, 0x17, 0x49, 0x5C, 0x39, 0x88, 0x58, 0x03, 0x99,
        0x88, 0x42, 0x07, 0xDD, 0x28, 0x21, 0x61, 0x43, 0x19, 0x4A, 0x40, 0x32,
        0x89, 0x18, 0xAA, 0x00, 0x88, 0x50, 0x07, 0xE0, 0x28, 0x21, 0x61, 0x43,
        0x15, 0x4B, 0x40, 0x33, 0xC9, 0x18, 0xAB, 0x00, 0x03, 0x9A, 0xCA, 0x50,
        0x00, 0xBF, 0x00, 0xBF, 0x0C, 0x20, 0x78, 0x43, 0x1A, 0xA9, 0x09, 0x58,
        0x05, 0x22, 0xD2, 0x03, 0x10, 0x98, 0x80, 0x18, 0x81, 0x42, 0x01, 0xDA,
        0x01, 0x20, 0x0F, 0x90, 0x0C, 0x98, 0x00, 0x28, 0x16, 0xD0, 0x0C, 0x20,
        0x78, 0x43, 0x1A, 0xA9, 0x09, 0x58, 0x08, 0x98, 0x08, 0x1A, 0x00, 0x12,
        0x05, 0x90, 0x21, 0xE0, 0x00, 0x3C, 0x20, 0x00, 0x88, 0x44, 0x20, 0x00,
        0x38, 0x3C, 0x20, 0x00, 0x08, 0x42, 0x20, 0x00, 0x3F, 0x42, 0x0F, 0x00,
        0x30, 0x75, 0x00, 0x00, 0x00, 0x3B, 0x20, 0x00, 0x0F, 0x98, 0x00, 0x28,
        0x08, 0xD0, 0x0C, 0x20, 0x78, 0x43, 0x1A, 0xA9, 0x09, 0x58, 0x10, 0x98,
        0x08, 0x1A, 0x00, 0x12, 0x05, 0x90, 0x07, 0xE0, 0x0C, 0x20, 0x78, 0x43,
        0x1A, 0xA9, 0x09, 0x58, 0x08, 0x98, 0x08, 0x1A, 0x00, 0x12, 0x05, 0x90,
        0x05, 0x98, 0x00, 0x28, 0x03, 0xDA, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0x20,
        0x05, 0x90, 0x68, 0x10, 0x81, 0x00, 0x5B, 0x48, 0x40, 0x58, 0x80, 0x08,
        0x05, 0x99, 0x48, 0x43, 0x40, 0x0B, 0x59, 0x49, 0x48, 0x43, 0x57, 0x49,
        0x09, 0x1F, 0x09, 0x6B, 0x48, 0x43, 0x40, 0x0B, 0x04, 0x90, 0x04, 0x98,
        0x00, 0x28, 0x01, 0xDC, 0x01, 0x20, 0x04, 0x90, 0x0C, 0x98, 0x01, 0x28,
        0x06, 0xD1, 0x52, 0x48, 0x43, 0x6F, 0x19, 0x9A, 0x10, 0x99, 0x04, 0x98,
        0x98, 0x47, 0x04, 0x90, 0x06, 0x98, 0x02, 0x28, 0x69, 0xDA, 0x4E, 0x49,
        0x04, 0x98, 0x88, 0x42, 0x63, 0xDA, 0x00, 0xBF, 0x00, 0xBF, 0x0C, 0x21,
        0x79, 0x43, 0x1A, 0xAA, 0x89, 0x18, 0x48, 0x68, 0x17, 0x99, 0x49, 0x1C,
        0x01, 0xF7, 0x7E, 0xFC, 0x02, 0x90, 0x43, 0x48, 0x00, 0x1F, 0x00, 0x68,
        0x40, 0x68, 0x80, 0x21, 0x08, 0x40, 0x00, 0x28, 0x04, 0xD0, 0x02, 0x98,
        0xFF, 0xF7, 0x32, 0xFD, 0x01, 0x90, 0x01, 0xE0, 0x02, 0x98, 0x01, 0x90,
        0x01, 0x98, 0xFF, 0x28, 0x02, 0xDC, 0x01, 0x98, 0x00, 0x28, 0x01, 0xDA,
        0xFF, 0x20, 0x01, 0x90, 0x3B, 0x48, 0x80, 0x78, 0x40, 0x1C, 0x3A, 0x49,
        0x88, 0x70, 0x12, 0x21, 0x06, 0x98, 0x48, 0x43, 0xE1, 0x00, 0x61, 0x18,
        0x41, 0x18, 0x68, 0x1E, 0x08, 0x18, 0x03, 0x90, 0x01, 0x98, 0xC1, 0xB2,
        0x03, 0x98, 0x82, 0x00, 0x32, 0x48, 0x14, 0x30, 0x10, 0x18, 0x81, 0x70,
        0x04, 0x98, 0x81, 0xB2, 0x03, 0x98, 0x82, 0x00, 0x2E, 0x48, 0x14, 0x30,
        0x81, 0x52, 0x03, 0x98, 0x82, 0x00, 0x2C, 0x48, 0x14, 0x30, 0x10, 0x18,
        0xC5, 0x70, 0x26, 0x48, 0xFC, 0x30, 0xC1, 0x69, 0x04, 0x98, 0x81, 0x42,
        0x03, 0xD9, 0x23, 0x49, 0xFC, 0x31, 0x04, 0x98, 0xC8, 0x61, 0x21, 0x48,
        0xFC, 0x30, 0xC8, 0x22, 0x01, 0x6A, 0x04, 0x98, 0x02, 0xF7, 0x6A, 0xFF,
        0x00, 0x28, 0x09, 0xD0, 0x20, 0x48, 0x81, 0x68, 0x0C, 0x20, 0x78, 0x43,
        0x1A, 0xAA, 0x80, 0x18, 0x80, 0x68, 0x08, 0x18, 0x1C, 0x49, 0x88, 0x60,
        0x01, 0xE0, 0x00, 0xBF, 0x00, 0xBF, 0x06, 0x98, 0x40, 0x1C, 0x06, 0x90,
        0x7F, 0x1C, 0x14, 0x98, 0x87, 0x42, 0x00, 0xDA, 0xE8, 0xE6, 0x00, 0xBF,
        0x6D, 0x1C, 0x0A, 0x2D, 0x04, 0xDA, 0x15, 0x48, 0x00, 0x78, 0x00, 0x28,
        0x00, 0xD1, 0x27, 0xE6, 0x0F, 0x48, 0x23, 0x46, 0x10, 0x4A, 0x80, 0x21,
        0x45, 0x6E, 0x13, 0x98, 0xA8, 0x47, 0x10, 0x49, 0x08, 0x6B, 0x80, 0x47,
        0x61, 0x1C, 0x88, 0x42, 0x03, 0xD1, 0x07, 0x48, 0xFC, 0x30, 0xC1, 0x69,
        0x01, 0x62, 0x07, 0x48, 0x22, 0x46, 0x03, 0x6C, 0x25, 0x99, 0x24, 0x98,
        0x98, 0x47, 0x40, 0xB2, 0x23, 0x90, 0x23, 0x98, 0x63, 0xE5, 0x00, 0x00,
        0x84, 0x3A, 0x20, 0x00, 0x51, 0x07, 0x00, 0x00, 0x38, 0x3C, 0x20, 0x00,
        0xB4, 0x14, 0x00, 0x00, 0x88, 0x44, 0x20, 0x00, 0x00, 0x40, 0x20, 0x00,
        0x38, 0x3F, 0x20, 0x00, 0xF8, 0xB5, 0x05, 0x46, 0x0E, 0x46, 0xB4, 0x20,
        0x68, 0x43, 0x0F, 0x49, 0x44, 0x18, 0xA8, 0x20, 0x00, 0x5B, 0x00, 0x04,
        0xC7, 0x0E, 0xA8, 0x20, 0x00, 0x59, 0x1F, 0x21, 0xC9, 0x02, 0x88, 0x43,
        0xA8, 0x21, 0x08, 0x51, 0x31, 0x46, 0x28, 0x46, 0x07, 0xF7, 0x0E, 0xF8,
        0xA8, 0x20, 0x00, 0x59, 0x1F, 0x21, 0xC9, 0x02, 0x88, 0x43, 0xF9, 0x02,
        0x1F, 0x22, 0xD2, 0x02, 0x11, 0x40, 0x08, 0x43, 0xA8, 0x21, 0x08, 0x51,
        0xF8, 0xBD, 0x00, 0x00, 0xCC, 0x3D, 0x20, 0x00, 0x00, 0x00, 0x88, 0x05,
        0x37, 0x0B, 0x27, 0x11, 0x65, 0x17, 0x02, 0x1E, 0x1E, 0x25, 0xBF, 0x2C,
        0xF5, 0x34, 0xC7, 0x3D, 0x27, 0x47, 0xF6, 0x50, 0x09, 0x5B, 0x38, 0x65,
        0x61, 0x6F, 0x72, 0x79, 0x62, 0x83, 0x30, 0x8D, 0xDC, 0x96, 0x62, 0xA0,
        0xBA, 0xA9, 0xD9, 0xB2, 0xAE, 0xBB, 0x2B, 0xC4, 0x3F, 0xCC, 0xE9, 0xD3,
        0x2E, 0xDB, 0x06, 0xE2, 0x8B, 0xE8, 0xB8, 0xEE, 0xA9, 0xF4, 0x68, 0xFA,
        0xFF, 0xFF, 0x00, 0x00
    ];
    private const ushort ImageStartAddress = 0x0000;
    private const byte ChunkSize = 128;
    private const byte DownloadInitParam = 0x29;

    public void DownloadImage()
    {           
        if (GetAppId() != AppId.Bootloader)
            return; // application already active, no need to re-flash

        // 1) DOWNLOAD_INIT
        SendBootloaderCommand(CMD_DOWNLOAD_INIT, [DownloadInitParam]);
        WaitBootloaderReady();

        // 2) SET_ADDR
        SetBootloaderAddress(ImageStartAddress);
        WaitBootloaderReady();

        // 3) W_RAM chunks
        int offset = 0;
        while (offset < _image.Length)
        {
            int len = Math.Min(ChunkSize, _image.Length - offset);
            WriteBootloaderRamChunk(_image.AsSpan(offset, len));
            WaitBootloaderReady();
            offset += len;
        }

        // 4) RAMREMAP_RESET and wait for application
        SendBootloaderCommand(CMD_RAMREMAP_RESET, []);
        WaitForAppId(AppId.Application, 10);
    }


    private void ClearIntStatus(byte mask)
    {
        // R_PUSH1: writing '1' clears the corresponding interrupt bit :contentReference[oaicite:11]{index=11}
        I2C.WriteReg(REG_INT_STATUS, mask);
    }

    // CMD_STAT: device writes back 0x00..0x0F when done :contentReference[oaicite:2]{index=2}
    void WaitCmdDone(int timeoutMs = 1000)
    {
        int t0 = Environment.TickCount;

        while (Environment.TickCount - t0 < timeoutMs)
        {
            byte v = I2C.ReadReg(CMD_STAT); 

            // Command range is 0x10..0xFF, status range is 0x00..0x0F :contentReference[oaicite:3]{index=3}
            if (v <= 0x0F)
            {
                // 0x00 = STAT_OK, 0x01 = STAT_ACCEPTED, other values are errors :contentReference[oaicite:4]{index=4}
                if (v == 0x00 || v == 0x01) return;

                throw new Exception($"TMF882X: CMD_STAT error status=0x{v:X2}");
            }

            Thread.Sleep(2);
        }

        throw new TimeoutException("TMF882X: CMD_STAT timeout (no status returned).");
    }

    private void WaitCommandHandled(int timeoutMs = 200)
    {
        int start = Environment.TickCount;
        while (Environment.TickCount - start < timeoutMs)
        {
            byte st = I2C.ReadReg(REG_INT_STATUS);
            if ((st & IntStatus.Int6()) != 0)
            {
                ClearIntStatus(IntStatus.Int6());
                return;             
            }
            Thread.Sleep(2);
        }
        // If you want, log CMD_STAT here (0x00..0x0F = status; >0x0F = command range) :contentReference[oaicite:12]{index=12}
        throw new TimeoutException("TMF882X: command not acknowledged (INT6).");
    }

    private void WaitForResultsPage(int timeoutMs = 500)
    {
        int start = Environment.TickCount;
        while (Environment.TickCount - start < timeoutMs)
        {
            byte cid = I2C.ReadReg(REG_CONFIG_RESULT);
            if (cid == 0x10) return; // MEASUREMENT_RESULT :contentReference[oaicite:13]{index=13}
            Thread.Sleep(5);
        }
        throw new TimeoutException("TMF882X: results page (cid_rid=0x10) never became active.");
    }

    private static byte BootloaderChecksum(byte cmd, byte size, ReadOnlySpan<byte> data)
    {
        int sum = cmd + size;
        for (int i = 0; i < data.Length; i++) sum += data[i];
        return (byte)(0xFF ^ (sum & 0xFF));
    }

    private void SendBootloaderCommand(byte cmd, ReadOnlySpan<byte> data)
    {
        if (data.Length > 255)
            throw new ArgumentOutOfRangeException(nameof(data), "TMF882X: bootloader payload size > 255.");

        byte size = (byte)data.Length;
        var buffer = new byte[4 + data.Length];
        buffer[0] = REG_CMD_STAT;
        buffer[1] = cmd;
        buffer[2] = size;
        data.CopyTo(buffer.AsSpan(3));
        buffer[^1] = BootloaderChecksum(cmd, size, data);

        I2C.WriteBytes(buffer);
    }

    private void WaitBootloaderReady(int timeoutMs = 1000)
    {
        int start = Environment.TickCount;
        while (Environment.TickCount - start < timeoutMs)
        {
            // The host should wait until it reads back the following 3 bytes: 0x00 0x00 0xFF
            byte[] status = I2C.ReadRegs(REG_CMD_STAT, 3);
            if (status[0] == 0x00 && status[1] == 0x00 && status[2] == 0xFF)
                return;

            if (status[0] >= 0x01 && status[0] <= 0x0F)
                throw new Exception($"TMF882X: bootloader CMD_STAT error=0x{status[0]:X2} (csum/size/command).");

            Thread.Sleep(2);
        }

        throw new TimeoutException("TMF882X: bootloader not ready (CMD_STAT != 00 00 FF).");
    }

    private void SetBootloaderAddress(ushort address)
    {
        Span<byte> payload = stackalloc byte[2];
        payload[0] = (byte)(address & 0xFF);
        payload[1] = (byte)((address >> 8) & 0xFF);
        SendBootloaderCommand(CMD_SET_ADDR, payload);
    }

    private void WriteBootloaderRamChunk(ReadOnlySpan<byte> data)
    {
        if (data.Length == 0)
            throw new ArgumentOutOfRangeException(nameof(data), "TMF882X: empty chunk.");
        if (data.Length > 255)
            throw new ArgumentOutOfRangeException(nameof(data), "TMF882X: chunk > 255.");

        SendBootloaderCommand(CMD_W_RAM, data);
    }

    private void WaitForAppId(AppId expected, int timeoutMs = 10)
    {
        int start = Environment.TickCount;
        while (Environment.TickCount - start < timeoutMs)
        {
            var value = I2C.ReadReg(REG_APPID);
            if (value == (byte) expected)
                return;
            Thread.Sleep(1);
        }
        throw new TimeoutException($"TMF882X: APPID 0x{expected:X2} not reached after download.");
    }

    public void Start()
    {
        // (Optional but useful) ensure measurement app (0x03) is running, otherwise you're in bootloader. :contentReference[oaicite:5]{index=5}
        byte appid = I2C.ReadReg(0x00);
        if (appid != 0x03)
            throw new Exception($"TMF882X: APPID=0x{appid:X2} (not measurement app 0x03).");

        // Load common page
        I2C.WriteReg(0x08, 0x16);     // CMD_LOAD_CONFIG_PAGE_COMMON :contentReference[oaicite:6]{index=6}
        WaitCmdDone(1000);

        // Configure period/iterations
        I2C.WriteReg(0x24, 50); I2C.WriteReg(0x25, 0);
        I2C.WriteReg(0x26, 25); I2C.WriteReg(0x27, 0);

        // Commit config
        I2C.WriteReg(0x08, 0x15);     // CMD_WRITE_CONFIG_PAGE :contentReference[oaicite:7]{index=7}
        WaitCmdDone(1000);

        // Start measure
        I2C.WriteReg(0x08, 0x10);     // CMD_MEASURE :contentReference[oaicite:8]{index=8}
        WaitCmdDone(1000);
    }

    public void Start2(int periodMs = 50, int kiloIterations = 25)
    {
        // (Optional but useful) ensure measurement app (0x03) is running, otherwise you're in bootloader. :contentReference[oaicite:5]{index=5}
        byte appid = I2C.ReadReg(0x00);
        if (appid != 0x03)
            throw new Exception($"TMF882X: APPID=0x{appid:X2} (not measurement app 0x03).");

        // Optional but useful: ensure cpu_ready=1 before touching pages :contentReference[oaicite:14]{index=14}
        byte en = I2C.ReadReg(REG_ENABLE);
        bool cpuReady = (en & (1 << 6)) != 0;
        if (!cpuReady)
            throw new InvalidOperationException("TMF882X: ENABLE.cpu_ready=0 (firmware not ready / standby/bootloader mode).");

        // Load common config page
        I2C.WriteReg(REG_CMD_STAT, CMD_LOAD_CONFIG_PAGE_COMMON);
        WaitCommandHandled();

        // Configure
        I2C.WriteReg(REG_PERIOD_LSB, (byte)(periodMs & 0xFF));
        I2C.WriteReg(REG_PERIOD_MSB, (byte)((periodMs >> 8) & 0xFF));
        I2C.WriteReg(REG_KILO_ITER_LSB, (byte)(kiloIterations & 0xFF));
        I2C.WriteReg(REG_KILO_ITER_MSB, (byte)((kiloIterations >> 8) & 0xFF));

        // Commit config
        I2C.WriteReg(REG_CMD_STAT, CMD_WRITE_CONFIG_PAGE);
        WaitCommandHandled();

        // Start measurement
        I2C.WriteReg(REG_CMD_STAT, CMD_MEASURE);
        WaitCommandHandled();

        // Wait until the results page is active (otherwise reads at 0x24.. are not results)
        WaitForResultsPage();
    }

    void ClearInt(byte mask) => I2C.WriteReg(REG_INT_STATUS, mask);

    void WaitInt(byte mask, int timeoutMs)
    {
        int t0 = Environment.TickCount;
        while (Environment.TickCount - t0 < timeoutMs)
        {
            if ((I2C.ReadReg(REG_INT_STATUS) & mask) != 0)
            {
                ClearInt(mask);
                return;
            }
            Thread.Sleep(5);
        }
        throw new TimeoutException("TMF882X: timeout INT");
    }

    public (ushort dist, byte conf) ReadOnce()
    {
        WaitInt(IntStatus.Int2(), 5000);

        byte conf = I2C.ReadReg(REG_CONF0);
        byte lo = I2C.ReadReg(REG_DIST0_LSB);
        byte hi = I2C.ReadReg(REG_DIST0_MSB);
        return ((ushort)(lo | (hi << 8)), conf);
    }

    public void Stop() => I2C.WriteReg(REG_CMD_STAT, CMD_STOP);

    public (ushort distanceMm, byte confidence) ReadZone1()
    {
        // You can keep your block read starting at 0x20 if you want.
        // But at minimum, ensure CONFIG_RESULT==0x10 first.
        if (I2C.ReadReg(REG_CONFIG_RESULT) != 0x10)
            throw new InvalidOperationException("TMF882X: not on results page (cid_rid != 0x10).");

        // zone0 distance/confidence (cid_rid=0x10) :contentReference[oaicite:15]{index=15}
        byte conf = I2C.ReadReg(0x38);
        byte dL = I2C.ReadReg(0x39);
        byte dH = I2C.ReadReg(0x3A);
        return ((ushort)(dL | (dH << 8)), conf);
    }

    public void WaitForNextSample_Int2(int timeoutMs = 5000, int pollMs = 5)
    {
        int start = Environment.TickCount;

        while (Environment.TickCount - start < timeoutMs)
        {
            byte st = I2C.ReadReg(REG_INT_STATUS);
            if ((st & IntStatus.Int2()) != 0)
            {
                // result ready
                ClearIntStatus(IntStatus.Int2());
                return;
            }
            Thread.Sleep(pollMs);
        }

        throw new TimeoutException($"TMF882X: no result (INT2) within {timeoutMs} ms.");
    }
}